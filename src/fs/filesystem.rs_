use std::path::{Component, PathBuf};

use serde_json::json;

use super::{AdbFileSystem, FileInfo, FileType};


/// In-memory tree of the remote filesystem built from `FileInfo` entries.
#[derive(Debug, Clone)]
pub struct FileSystem {
    root: DirectoryNode,
}

impl FileSystem {
    /// Create an empty filesystem rooted at the given path (e.g. "/").
    pub fn new(root_path: impl Into<PathBuf>) -> Self {
        let root_path = root_path.into();
        Self {
            root: DirectoryNode::new("/".to_string(), root_path, None),
        }
    }

    /// Build a filesystem tree from an iterator of `FileInfo` entries.
    pub fn from_entries(
        root_path: impl Into<PathBuf>,
        entries: impl IntoIterator<Item = FileInfo>,
    ) -> Self {
        let mut fs = Self::new(root_path);
        for entry in entries {
            fs.add_entry(entry);
        }
        fs
    }

    /// Insert a single entry (file or directory) into the tree, creating parent folders as needed.
    pub fn add_entry(&mut self, entry: FileInfo) {
        let root_path = self.root.path.clone();
        let mut path_so_far = root_path.clone();
        let mut current = &mut self.root;

        // Compute components relative to root, but tolerate entries outside root by using full path.
        let relative_components: Vec<Component> = entry
            .path
            .strip_prefix(&root_path)
            .unwrap_or(entry.path.as_path())
            .components()
            .collect();

        // If the entry matches the root path exactly, attach metadata or file at the root.
        if relative_components.is_empty() {
            match entry.file_type {
                FileType::Directory => {
                    if current.info.is_none() {
                        current.info = Some(entry);
                    }
                }
                _ => {
                    if !current.files.iter().any(|f| f.path == entry.path) {
                        current.files.push(entry);
                    }
                }
            }
            return;
        }

        for (idx, comp) in relative_components.iter().enumerate() {
            let name = comp.as_os_str().to_string_lossy().to_string();
            path_so_far.push(&name);
            let is_last = idx + 1 == relative_components.len();

            if is_last {
                match entry.file_type {
                    FileType::Directory => {
                        let dir = if let Some(idx) =
                            current.directories.iter().position(|d| d.name == name)
                        {
                            &mut current.directories[idx]
                        } else {
                            current.directories.push(DirectoryNode::new(
                                name.clone(),
                                path_so_far.clone(),
                                Some(entry.clone()),
                            ));
                            current
                                .directories
                                .last_mut()
                                .expect("just inserted directory node")
                        };

                        if dir.info.is_none() {
                            dir.info = Some(entry.clone());
                        }
                    }
                    _ => {
                        if !current.files.iter().any(|f| f.path == entry.path) {
                            current.files.push(entry.clone());
                        }
                    }
                }
            } else {
                // Traverse/create intermediate directories
                let next =
                    if let Some(idx) = current.directories.iter().position(|d| d.name == name) {
                        &mut current.directories[idx]
                    } else {
                        current.directories.push(DirectoryNode::new(
                            name.clone(),
                            path_so_far.clone(),
                            None,
                        ));
                        current
                            .directories
                            .last_mut()
                            .expect("just inserted directory node")
                    };
                current = next;
            }
        }
    }

    /// Access the root directory node.
    pub fn root(&self) -> &DirectoryNode {
        &self.root
    }

    /// Mutable access to the root directory node.
    pub fn root_mut(&mut self) -> &mut DirectoryNode {
        &mut self.root
    }

    /// Serialize the filesystem tree to JSON.
    /// Each directory contains "type" (folder emoji), "name", "size", "lastModified", and optional "rows" array.
    pub fn to_json(&self) -> String {
        serde_json::to_string(&self.root.to_json_value()).unwrap_or_else(|_| "[]".to_string())
    }

    /// Build filesystem tree from `ls -lR` output.
    /// Parses directory headers (ending with ":") and entries (ls -l format).
    pub fn from_ls_lr(root_path: impl Into<PathBuf>, ls_lr_output: &str) -> Self {
        let root_path = root_path.into();
        let mut fs = Self::new(&root_path);

        let mut current_dir: Option<PathBuf> = None;

        for line in ls_lr_output.lines() {
            let trimmed = line.trim();

            // Skip empty lines and "total" lines
            if trimmed.is_empty() || trimmed.starts_with("total") {
                continue;
            }

            // Detect directory header (ends with ":" and no leading spaces in original)
            if line.ends_with(':') && !line.starts_with(' ') && !line.starts_with('\t') {
                let dir_path = trimmed.trim_end_matches(':').to_string();
                current_dir = Some(PathBuf::from(&dir_path));

                // Ensure the directory exists in the tree
                if let Some(path) = &current_dir {
                    let entry = FileInfo {
                        path: path.clone(),
                        file_type: FileType::Directory,
                        size: 0,
                        permissions: super::FilePermissions {
                            mode: 0,
                            owner: String::new(),
                            group: String::new(),
                        },
                        modified_time: std::time::SystemTime::now(),
                        accessed_time: None,
                        created_time: None,
                    };
                    fs.add_entry(entry);
                }
                continue;
            }

            // Parse file/directory entries
            let parts: Vec<&str> = trimmed.split_whitespace().collect();
            if parts.len() < 9 {
                continue; // Not a valid ls -l entry
            }

            let perms = parts[0];
            let name = parts[8];
            let is_dir = perms.starts_with('d');

            if let Some(dir_path) = &current_dir {
                let entry_path = if dir_path.to_string_lossy().ends_with('/') {
                    PathBuf::from(format!("{}{}", dir_path.display(), name))
                } else {
                    dir_path.join(name)
                };

                let file_type = if is_dir {
                    FileType::Directory
                } else {
                    FileType::File
                };

                let entry = FileInfo {
                    path: entry_path,
                    file_type,
                    size: 0, // Not available from ls -lR output
                    permissions: super::FilePermissions {
                        mode: 0,
                        owner: String::new(),
                        group: String::new(),
                    },
                    modified_time: std::time::SystemTime::now(),
                    accessed_time: None,
                    created_time: None,
                };

                fs.add_entry(entry);
            }
        }

        fs
    }

    /// Build filesystem tree from `find / -type d -print` output.
    /// Parses simple directory paths (one per line).
    /// Very fast: only directories, no file entries, minimal parsing.
    ///
    /// Example input:
    /// ```text
    /// /odm_dlkm
    /// /cache
    /// /system_dlkm
    /// /system_dlkm/etc
    /// /system_dlkm/lib
    /// /system_dlkm/lib/modules
    /// ```
    pub fn load_folders_tree(root_path: impl Into<PathBuf>) -> Self {
        let root_path = root_path.into();
        let adb = AdbFileSystem::new(None).with_root();
        let find_output = adb.list_folders_tree(&root_path).unwrap_or_default();
        let mut fs = Self::new(&root_path);

        for line in find_output {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }

            let dir_path = PathBuf::from(trimmed);

            // Create directory entry
            let entry = FileInfo {
                path: dir_path,
                file_type: FileType::Directory,
                size: 0,
                permissions: super::FilePermissions {
                    mode: 0,
                    owner: String::new(),
                    group: String::new(),
                },
                modified_time: std::time::SystemTime::now(),
                accessed_time: None,
                created_time: None,
            };

            fs.add_entry(entry);
        }

        fs
    }
}

/// Directory node containing nested folders and files.
#[derive(Debug, Clone)]
pub struct DirectoryNode {
    name: String,
    path: PathBuf,
    info: Option<FileInfo>,
    directories: Vec<DirectoryNode>,
    files: Vec<FileInfo>,
}

impl DirectoryNode {
    fn new(name: String, path: PathBuf, info: Option<FileInfo>) -> Self {
        Self {
            name,
            path,
            info,
            directories: Vec::new(),
            files: Vec::new(),
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn path(&self) -> &PathBuf {
        &self.path
    }

    /// Metadata for this directory, if it was provided by a `FileInfo` entry.
    pub fn info(&self) -> Option<&FileInfo> {
        self.info.as_ref()
    }

    pub fn directories(&self) -> &[DirectoryNode] {
        &self.directories
    }

    pub fn directories_mut(&mut self) -> &mut [DirectoryNode] {
        &mut self.directories
    }

    pub fn files(&self) -> &[FileInfo] {
        &self.files
    }

    pub fn files_mut(&mut self) -> &mut [FileInfo] {
        &mut self.files
    }

    /// Convert this directory node to a JSON value.
    /// Returns a JSON object with "type", "name", "size", "lastModified", and optional "rows".
    pub fn to_json_value(&self) -> serde_json::Value {
        use serde_json::json;

        let mut rows = Vec::new();

        // Add subdirectories
        for dir in &self.directories {
            rows.push(dir.to_json_value());
        }

        // Add files
        for file in &self.files {
            let file_name = file.path.file_name().unwrap_or_default().to_string_lossy();
            rows.push(json!({
                "type": "ðŸ“„",
                "name": file_name.to_string(),
                "size": format_size(file.size),
                "lastModified": file.modified_time.duration_since(std::time::UNIX_EPOCH)
                    .map(|d| d.as_secs())
                    .unwrap_or(0)
                    .to_string(),
            }));
        }

        let mut obj = json!({
            "type": "ðŸ“",
            "name": self.name,
            "size": "",
            "lastModified": self.info.as_ref()
                .and_then(|i| i.modified_time.duration_since(std::time::UNIX_EPOCH).ok())
                .map(|d| d.as_secs().to_string())
                .unwrap_or_default(),
        });

        if !rows.is_empty() {
            obj["rows"] = serde_json::Value::Array(rows);
        }

        obj
    }
}

/// Format file size in human-readable format
fn format_size(size: u64) -> String {
    if size < 1024 {
        format!("{}B", size)
    } else if size < 1024 * 1024 {
        format!("{:.1}KB", size as f64 / 1024.0)
    } else if size < 1024 * 1024 * 1024 {
        format!("{:.1}MB", size as f64 / (1024.0 * 1024.0))
    } else {
        format!("{:.1}GB", size as f64 / (1024.0 * 1024.0 * 1024.0))
    }
}
